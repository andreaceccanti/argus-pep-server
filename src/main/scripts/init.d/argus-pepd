#!/bin/bash
#
# Copyright (c) Members of the EGEE Collaboration. 2006-2010.
# See http://www.eu-egee.org/partners/ for details on the copyright holders.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Startup script for PEP daemon server
#
# chkconfig: 2345 97 97
#
# description: PEPd Server starting script
#
### BEGIN INIT INFO
# Provides:          argus-pepd
# Required-Start:    $network $remote_fs argus-pap argus-pdp
# Required-Stop:     $network $remote_fs argus-pap argus-pdp
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start pep-daemon at boot time
# Description:       Provides the PEP-server function of the Argus-service
### END INIT INFO
#
# Author(s): Maria Alandes Pradillo <yaim-contact@cern.ch>
#            Valery Tschopp <argus-support@cern.ch>
#            Joel Casutt <argus-support@cern.ch>
#
# Version: V2.0
#
# Date: 10/10/2011
###############################################################################
# set -x

# PEP server control script and name of the script
PEPDCTL="/usr/sbin/pepdctl"
NAME="argus-pepd"

if [ `id -u` -ne 0 ]; then
    echo "You need root privileges to run this script"
    exit 1
fi 

# Source functions Library
if [ -r "/lib/lsb/init-functions" ]; then
    source /lib/lsb/init-functions
else
    echo "/lib/lsb/init-functions must be present to run this script"
    exit 1
fi

PEPD_PROG="${NAME}"
SHUTDOWN_WAIT=10
HAS_LOCK=0
PEPD_LOCK=
PEPD_PID=${PEPD_PID:-"/var/run/${NAME}.pid"}
RETURN_CODE=0

# See if there is an appropriate location for the lock-file, if not, do not use a lock-file
if [ -d "/var/lock/subsys" ]; then
    PEPD_LOCK="/var/lock/subsys/${NAME}"
    HAS_LOCK=1
elif [ -d "/var/lock" ]; then
    PEPD_LOCK="/var/lock/${NAME}"
    HAS_LOCK=1
fi

# source optional system configuration
if [ -r "/etc/sysconfig/argus-pepd" ]; then
    # Auto-export variables to subsequent scripts
    set -a
    source /etc/sysconfig/argus-pepd
fi


# Function to start the PEPd daemon
function start() {
echo -n "Starting ${PEPD_PROG}... "
    if [ $RETURN_CODE -ne 0 ]; then 
        log_failure_msg
        return 4
    fi
    _current_state
    if [ $HAS_LOCK -eq 1 ]; then
        if [ -f "$PEPD_LOCK" ]; then
            if [ -f "$PEPD_PID" ]; then
                read kpid < $PEPD_PID
                if [ -d "/proc/${kpid}" ]; then
                    log_success_msg
                    return 0
                fi
            fi
        fi
    else
        if [ -f "$PEPD_PID" ]; then
            read kpid < $PEPD_PID
            if [ -d "/proc/${kpid}" ]; then
                log_success_msg
                return 0
            fi
        fi
    fi
    touch $PEPD_PID 2>&1 || RETURN_CODE=4
    if [ $RETURN_CODE -eq 0 ]; then
        $PEPDCTL start || RETURN_CODE=4
    fi
    if [ $RETURN_CODE -eq 0 ]; then 
        log_success_msg
        if [ -n "$PEPD_LOCK" -a $HAS_LOCK -eq 1 ]; then
            touch $PEPD_LOCK
        fi
    else
        log_failure_msg "Error code ${RETURN_CODE}"
    fi
}

# Function to stop the PEPd daemon
function stop() {
echo -n "Stopping ${PEPD_PROG}... "
    if [ -f "$PEPD_PID" ]; then
        if [ $RETURN_CODE -eq 0 ]; then
            if [ $HAS_LOCK -eq 1 ]; then
                touch $PEPD_LOCK 2>&1 || RETURN_CODE=4
            fi
            [ $RETURN_CODE -eq 0 ] && $PEPDCTL stop || RETURN_CODE=4
        fi
        if [ $RETURN_CODE -eq 0 ]; then
            count=0
            if [ -f "$PEPD_PID" ]; then
                read kpid < $PEPD_PID
                until [ $(ps --pid $kpid | grep -c $kpid) -eq 0 ] || [ $count -gt $SHUTDOWN_WAIT ]; do
                    sleep 1
                    let count=${count}+1
                done
                if [ $count -gt $SHUTDOWN_WAIT ]; then
                    log_warning_msg "killing processes which did not stop after ${SHUTDOWN_WAIT} seconds"
                    kill -9 $kpid
                fi
                log_success_msg
            fi
            rm -f $PEPD_PID
            if [ $HAS_LOCK -eq 1 ]; then
                rm -f $PEPD_LOCK
            fi
        else
            log_failure_msg
            RETURN_CODE=4
        fi
    else
        log_success_msg
        RETURN_CODE=0
    fi
}

# Function to read the status of the PEPD
function status() {
    _current_state
    if [ $? -eq 5 ]; then
        echo "${PEPD_PROG} is not running..."
        RETURN_CODE=4
    else
        $PEPDCTL status
    fi
}

# tests if the current process exists and if it has an associated pid and lock file. Return codes are as followed:
# 0 = process is running correctly (and has both, a pid and a lock file)
# 1 = the function exited unexpected (fatal error)
# 2 = process is running and has a lock file, but no pid file, The pid-file is created
# 3 = process is running and has a pid file, but no lock file. The lock-file is created
# 4 = process is running and has no pid and no lock file. Both files are created
# 5 = process is not running. Possible stale files are removed
function _current_state() {
    local pid=`pgrep -f org.glite.authz.pep.server.PEPDaemon`
    
    if [ -z $pid ]; then
        rm -f $PEPD_PID
        if [ $HAS_LOCK -eq 1 ]; then
            rm -f $PEPD_LOCK
        fi
        return 5
    fi
    if [ $HAS_LOCK -eq 1 ]; then
        if [ -f "$PEPD_LOCK" -a ! -f "$PEPD_PID" ]; then
            touch $PEPD_PID 2>&1
            echo $pid > $PEPD_PID
            return 2
        elif [ -f "$PEPD_PID" -a ! -f "$PEPD_LOCK" ]; then
            touch $PEPD_LOCK
            return 3
        elif [ -f "$PEPD_PID" -a -f "$PEPD_LOCK" ]; then
            return 0
        else
            touch $PEPD_PID 2>&1
            echo $pid > $PEPD_PID
            touch $PEPD_LOCK
            return 4
        fi
    else
        if [! -f "$PEPD_PID" ]; then
            touch $PEPD_PID 2>&1
            echo $pid > $PEPD_PID
            return 2
        else
            return 0
        fi
    fi
}


case "$1" in
    start)
        start
        ;; 
    stop)
        stop
        ;;
    restart)
        stop
        start
        ;;
    status)
        status
        ;;
    version)
        $PEPDCTL version
        ;;
    clearcache)
        $PEPDCTL clearResponseCache
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status|version|clearcache}"
        exit 1
        ;;
esac

exit $RETURN_CODE
